<!DOCTYPE html>
<html lang="en-US">
  <head>
    <title>Crafting a exploit for a (very basic) browser</title>
    <link rel="stylesheet" type="text/css" href="./../style.css">
    <link rel="icon" href="./../temp-icon.png">
  </head>
  <body>
    <header>
      <nav>
	<ul>
	  <li><a href="./../index.html">Home</a></li>
	  <li><a href="./../research/research.html">Research</a></li>
	  <li><a href="./../teaching/teaching.html">Teaching</a></li>
	  <li><a href="./../misc/misc.html">Miscellaneous</a></li>
	  <li><a href="./../blog/blog.html">Blog</a></li>
	</ul>
      </nav>
    </header>
    <article>
      <h1>Crafting a exploit for a (very basic) browser</h1>
      <p>Date written: 2021.10.27</p>
      <p>Let's start with a puzzle:</p>
      <figure>
	<blockquote>
	  <p>By changing up to three <em>characters</em> in the procedure called <code>simple</code> below, make the program print <code>c is: 1</code>.</p>
	</blockquote>
      </figure>

<pre style="background-color:#333333;">
// bo.c
#include &lt;stdio.h&gt;

void simple(char a) {
    char buffer[4];
    *buffer = a;
    *(buffer + 1) = a;
    *(buffer + 1) += 1;
}

void main() {
	char c = '1';
	simple(c);
	c = '2';
	printf("c is: %c\n", c);
}
</pre>

      <p>At first this seems impossible: after <code>simple(c);</code> is called the line <code>c = '2';</code> sets <code>c</code> to 2... so no matter how we change <code>simple</code> the program will always end up printing <code>c is: 2</code>, right?</p>

      <p>No. It is absolutely possible to change three characters of <code>bo.c</code> to instead print out <code>c is: 1</code>. We can do this because programs do not run in a vacuum but on hardware,
        and it is sometimes possible to utilize this knowledge to make them do unexpected things.</p>

      <p>This blog assumes that the program above was compiled to a 64-bit Linux executable using gcc version 9.3.0. Since different compilers on different operating systems with different hardware will produce different executables, the exact solution to the puzzle above depends on these factors. For example, my solution to this puzzle printed <code>c is: 1</code> on Linux, but when the same code was compiled on 64-bit Windows with Clang, the executable printed <code>c is: 2</code> instead.</p>

      <p>Let's begin. Like any good programming language, C is a compiled language, so let's compile <code>bo.c</code> with debug flags.</p>

<pre style="background-color:#333333;">
$ gcc -g -o bo bo.c
$ ./bo 
c is: 2
$ 
</pre>

      <p>For reference, here are the gcc details.</p>

<pre style="background-color:#333333;">
$ gcc --version
gcc (Ubuntu 9.3.0-17ubuntu1~20.04) 9.3.0
Copyright (C) 2019 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

$
</pre>

      <p>We'll use the <code>gdb</code> debugger to dive into the internals of how the program works. It provides basic information and is fairly simple to use.</p>

<pre style="background-color:#333333;">
$ gdb bo 
GNU gdb (Ubuntu 9.2-0ubuntu1~20.04) 9.2
Copyright (C) 2020 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
...
(gdb) 
</pre>

      <p>Let's examine what the <code>gcc</code> compiler ultimately did to our code.</p>

<pre style="background-color:#333333;">
(gdb) disass main
Dump of assembler code for function main:
   0x00005555555551b8 &lt;+0&gt;:	endbr64 
   0x00005555555551bc &lt;+4&gt;:	push   %rbp
   0x00005555555551bd &lt;+5&gt;:	mov    %rsp,%rbp
   0x00005555555551c0 &lt;+8&gt;:	sub    $0x10,%rsp
   0x00005555555551c4 &lt;+12&gt;:	movb   $0x31,-0x1(%rbp)
   0x00005555555551c8 &lt;+16&gt;:	movsbl -0x1(%rbp),%eax
   0x00005555555551cc &lt;+20&gt;:	mov    %eax,%edi
   0x00005555555551ce &lt;+22&gt;:	<span style="color:Orange;">callq</span>  0x555555555169 &lt;<span style="color:Plum;">simple</span>&gt;
   <span style="color:SkyBlue;">0x00005555555551d3</span> &lt;+27&gt;:	<span style="color:SkyBlue;">movb</span>   $<span style="color:Red;">0x32</span>,-0x1(%rbp)
   0x00005555555551d7 &lt;+31&gt;:	<span style="color:SkyBlue;">movsbl</span> -0x1(%rbp),%eax
   0x00005555555551db &lt;+35&gt;:	<span style="color:SkyBlue;">mov</span>    %eax,%esi
   0x00005555555551dd &lt;+37&gt;:	lea    0xe20(%rip),%rdi        # 0x555555556004
   0x00005555555551e4 &lt;+44&gt;:	mov    $0x0,%eax
   0x00005555555551e9 &lt;+49&gt;:	callq  0x555555555070 &lt;printf@plt&gt;
   0x00005555555551ee &lt;+54&gt;:	nop
   0x00005555555551ef &lt;+55&gt;:	leaveq 
   0x00005555555551f0 &lt;+56&gt;:	retq   
End of assembler dump.
(gdb)
</pre>

      <p>Here the debugger is showing us the x86 assembly instructions <code>gcc</code> turned our code into. We can see the program uses <code><span style="color:Orange;">callq</span></code> to jump to our <code><span style="color:Plum">simple</span></code> procedure. Once the <a href="https://en.wikipedia.org/wiki/Program_counter">instruction pointer</a> (IP) has jumped to the location of the
        <code><span style="color:Plum">simple</span></code> function and executed the instructions there it jumps back to the instruction following <code>callq</code>. This is <code><span style="color:SkyBlue;">movb</span></code>, and this and the subsequent instructions (<code><span style="color:SkyBlue;">movsbl</span></code>, <code><span style="color:SkyBlue;">mov</span></code>) copy the hex number <span style="color:Red;">0x32</span> (the <a href="https://en.wikipedia.org/wiki/ASCII#Printable_characters">ASCII printable character</a> <code>2</code>) in a roundabout way to the <code>esi</code> register so it can be printed. Note that there was no reason why the compiler had to use three move instructions instead of one. It's just that <code>gcc</code> isn't perfect at optimization.</p>

      <p>But how did the program know to jump back to <code>movb</code> once it was done with <code>simple</code>? It knows because the location of this instruction is stored on the stack. We can find this location with the debugger.</p>

      <p>We'll run the program and stop it when inside <code>simple</code>. This is easy to do by setting a breakpoint.</p>

<pre style="background-color:#333333;">
(gdb) list
1	// bo.c
2	#include &lt;stdio.h&gt;
3	
4	void simple(char a) {
5	    char buffer[4];
6	    *buffer = a;
7	    *(buffer + 1) = a;
8	    *(buffer + 1) += 1;
9	}
10	
(gdb) break 8
Breakpoint 1 at 0x1197: file bo.c, line 8.
(gdb) run
Starting program: ~/Documents/bo 

Breakpoint 1, simple (a=49 '1') at bo.c:8
8	    *(buffer + 1) += 1;
(gdb)
</pre>

      <p>The memory address of the <code>movb</code> instruction the IP jumps to after <code>simple</code> can be read off from the disassembly above (<span style="color:SkyBlue;">0x00005555555551d3</span>). It will be located above the bottom of the stack.</p> 
<pre style="background-color:#333333;">
(gdb) i r
rax            0x31                49
rbx            0x555555555200      93824992236032
rcx            0x555555555200      93824992236032
rdx            0x7fffffffe0d8      140737488347352
rsi            0x7fffffffe0c8      140737488347336
rdi            0x31                49
rbp            0x7fffffffdfb0      0x7fffffffdfb0
rsp            <span style="color:Plum;">0x7fffffffdf90</span>      0x7fffffffdf90
r8             0x0                 0
r9             0x7ffff7fe0d50      140737354009936
r10            0x0                 0
r11            0x0                 0
r12            0x555555555080      93824992235648
r13            0x7fffffffe0c0      140737488347328
r14            0x0                 0
r15            0x0                 0
rip            0x555555555197      0x555555555197 &lt;simple+46&gt;
eflags         0x246               [ PF ZF IF ]
cs             0x33                51
ss             0x2b                43
ds             0x0                 0
es             0x0                 0
fs             0x0                 0
gs             0x0                 0
(gdb)
</pre>

      <p>The stack pointer (SP) holds the bottom of the stack, which is <span style="color:Plum;">0x7fffffffdf90</span>. We can then use the debugger to directly examine the memory above it.</p>

<pre style="background-color:#333333;">
(gdb) x/8gx <span style="color:Plum;">0x7fffffffdf90</span>
<span style="color:Plum;">0x7fffffffdf90</span>:	0x00007fffffffdfb6	0x000055315555524d
0x7fffffffdfa0:	0x0000<span style="color:Orange;">3131</span>f7fb6fc8	0x51e4bd6119d63f00
0x7fffffffdfb0:	0x00007fffffffdfd0	<span style="color:SkyBlue;">0x00005555555551d3</span>
0x7fffffffdfc0:	0x00007fffffffe0c0	0x3100000000000000
(gdb)
</pre>

      <p>And there is the <span style="color:SkyBlue;">return address</span>! Now comes the hacking part. Notice that 20 bytes before the return address are the bytes <code><span style="color:Orange;">0x3131</span></code>... the values in the variable <code>buffer</code> which the <code>simple</code> procedure changes. So if we modify the C code <code>*(buffer + 1) += 1</code> to <code>*(buffer +20) += 1</code> we will now be modifying the return address.</p>

      <p>But if we can modify the return address, then we can make the program skip the part where <code>c</code> gets set to '2'. Looking at the disassembly from earlier, the instruction <code><span style="color:SkyBlue;">movsbl</span></code> occurs 4 bytes after the <code><span style="color:SkyBlue;">movb</span></code> instruction (31 - 27 = 4). Therefore if we replace <code>*(buffer + 1) += 1</code> with <code>*(buffer +20) += 4</code>, we should skip past the part where <code>c</code> gets sets to <code>'2'</code>.</p>

<pre style="background-color:#333333;">
// bo.c
#include &lt;stdio.h&gt;

void simple(char a) {
    char buffer[4];
    *buffer = a;
    *(buffer + 1) = a;
    *(buffer +<span style="color:Orange;">20</span>) += <span style="color:Orange;">4</span>;
}

void main() {
	char c = '1';
	simple(c);
	c = '2';
	printf("c is: %c\n", c);
}
</pre>

<p>With this change, when we compile and run the modified program...</p>

<pre style="background-color:#333333;">
$ gcc -o bo-sol bo.c
$ ./bo-sol 
c is: 1
$ 
</pre>

      <p>we get <code>c is: 1</code> like we wanted! (And we only had to change 3 characters in our program to do so!)</p>

      <p>I should note that I was somewhat lucky... if the last 8 bits of the return address held a value above 251 then adding four would have resulted in the incorrect return address, but the odds were in my favour.)</p>

      <p>So how is all of this relevant to crafting a browser exploit? We just changed a return address in the stack by altering the source code, but with a buffer overflow it may be possible to change a return address in the stack by simply rewriting over it. Once you can modify what the return address is, you may be able to make the program execute instructions of your own choosing, whereby the fun begins.</p>

      <p>I had to do all of the above and more for a project from a course I'm taking this semester (<a href="https://classes.cornell.edu/browse/roster/FA21/class/CS/3410">COMP3410</a>), which tasked us with the following:</p>
      <!-- archive link: https://web.archive.org/web/20220314134031/https://classes.cornell.edu/browse/roster/FA21/class/CS/3410 -->
      <figure>
	<blockquote>
	  <p>Develop an exploit for a RISC-V binary admitting a buffer overflow vulnerability.</p>
	</blockquote>
      </figure>

      <p>The course provided us with a specific and very minimal browser to exploit. Although the binary was not comprised of x86 instructions, which meant that there was not as much available documentation on crafting an exploit from a buffer overflow vulnerability, the RISC-V ISA is actually comprehensible. (Recall that x86 is a <a href="https://www.felixcloutier.com/x86/">gargantuan mess</a>.) The project's course page did give us a massive hint by linking to <a href="http://phrack.org/issues/49/14.html">an 1996 article from phrack magazine</a> which described how to develop an exploit from a buffer overflow vulnerability on a x86 binary on linux.</p>
      <!-- archive links: https://web.archive.org/web/20211008201118/https://www.felixcloutier.com/x86/ ; https://web.archive.org/web/20211007041956/http://phrack.org/issues/49/14.html  -->

      <p>Although the article was almost 25 years old, the C programming language is older, so much of the article held up. In fact, my puzzle at the beginning of this post was inspired by the article. Our course project was made significantly easier by the machine the RISC-V browser was running on <em>not</em> randomizing the location of the browser's stack. (I.e. it did not have <a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization">ASLR</a> turned on.) And in fact to make the assignment even easier, the browser was run on a simulator which assigned the same stack location to the browser each time. As such, my exploit was very small and had the following structure in bytes.</p>

<pre style="background-color:#333333;">
<span style="color:Red;">
AAAAAAAAAAAAAAAA</span><span style="color:Orange;">
BBBBBBBBBBBBBBBB
BBBBBBBBBBBBBBBB
BBBBBBBBBBBBBBBB
BBB</span><span style="color:LawnGreen;">CCCC</span><span style="color:SkyBlue;">DDDDDDDDD
DDDDDDDDDDDDDDDD
DDDDDDDDDDDDDDDD
DDDDDDDD</span><span style="color:Plum;">EEEEEEEE
EEEEEEEEEEEEEEEE
EEEEEEEEEEEEEE</span>
</pre>

      <p>In case the assignment is used when the course is taught again I don't want to post my actual exploit, but these are what the components of what it did:</p>
      <ul>
	<li><span style="color:Red">A:</span> These bytes made the browser take a branch to a return address which could be changed with a buffer overflow.</li>
	<li><span style="color:Orange">B:</span> Filler bytes to get to the return address.</li>
	<li><span style="color:LawnGreen">C:</span> The return address. I replaced it with the memory address of the word following it in the stack.</li>
	<li><span style="color:SkyBlue">D:</span> RISC-V instructions to print the string in the next component, and to replace specific characters in the next component with newline characters. Newlines had to be replaced otherwise the full payload would not have been written to the stack.</li>
	<li><span style="color:Plum">E:</span> A string to demonstrate we exploited the program.</li>
      </ul>

      <p>Overall I had a great time with the project. Everyone's heard of buffer overflow vulnerabilities, but actually turning a buffer overflow into an exploit required non-trivial knowledge. Knowing how to program in python or javascript is certainly not enough knowledge to be able to craft an exploit &mdash; doing so instead requires knowledge of how computers actually work. As I discovered, utilizing that knowledge to craft an exploit was very fun.</p>

</article>
<footer>
  <p>Benjamin Thompson, 2021 &mdash; 2022.</p>
</footer> 
</body>
</html>
